; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\users\matt\documents\visual studio 2015\projects\counter\main.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@KPFACFOE@Write?5something?3?5?$AA@	; `string'
PUBLIC	??_C@_0BE@IIDGBEEB@number?5of?5letters?3?5?$AA@	; `string'
PUBLIC	??_C@_0BE@EHPJAFPJ@number?5of?5numbers?3?5?$AA@	; `string'
PUBLIC	??_C@_0BC@KCLPILPH@number?5of?5other?3?5?$AA@	; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
EXTRN	__imp_?rdstate@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp____std_terminate:PROC
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KCLPILPH@number?5of?5other?3?5?$AA@
CONST	SEGMENT
??_C@_0BC@KCLPILPH@number?5of?5other?3?5?$AA@ DB 'number of other: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EHPJAFPJ@number?5of?5numbers?3?5?$AA@
CONST	SEGMENT
??_C@_0BE@EHPJAFPJ@number?5of?5numbers?3?5?$AA@ DB 'number of numbers: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IIDGBEEB@number?5of?5letters?3?5?$AA@
CONST	SEGMENT
??_C@_0BE@IIDGBEEB@number?5of?5letters?3?5?$AA@ DB 'number of letters: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KPFACFOE@Write?5something?3?5?$AA@
CONST	SEGMENT
??_C@_0BC@KPFACFOE@Write?5something?3?5?$AA@ DB 'Write something: ', 00H ; `string'
CONST	ENDS
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::move<std::basic_istream<char,std::char_traits<char> > &>
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
PUBLIC	?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
PUBLIC	?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
PUBLIC	??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
PUBLIC	_main
PUBLIC	?_Deallocate@std@@YAXPAXII@Z			; std::_Deallocate
PUBLIC	?_Allocate@std@@YAPAXII_N@Z			; std::_Allocate
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?to_int_type@?$char_traits@D@std@@SAHABD@Z	; std::char_traits<char>::to_int_type
PUBLIC	?to_char_type@?$char_traits@D@std@@SADABH@Z	; std::char_traits<char>::to_char_type
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?assign@?$char_traits@D@std@@SAPADPADID@Z	; std::char_traits<char>::assign
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	??2@YAPAXIPAX@Z					; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$_main DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$_main
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$_main DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_main$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$84
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$85
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$84 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$85 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$8
	DD	04H
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$9
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$10
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$26
__tryblocktable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$27
__catchsym$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$27 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT
; __Size$dead$ = ecx
; __Where$ = edx

; 88   :         (void)_Size;
; 89   :         return _Where;

	mov	eax, edx

; 90   :     }

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT
; __First$ = ecx

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LN3@length
	xor	eax, eax

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

	ret	0
$LN3@length:

; 523  : 		return (*_First == 0 ? 0

	lea	edx, DWORD PTR [ecx+1]
	npad	5
$LL5@length:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL5@length
	sub	ecx, edx
	mov	eax, ecx

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 529  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp

; 530  : 		return (_Count == 0 ? _First1

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN3@copy
	mov	eax, ecx

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

	pop	ebp
	ret	0
$LN3@copy:

; 530  : 		return (_Count == 0 ? _First1

	push	eax
	push	edx
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?assign@?$char_traits@D@std@@SAPADPADID@Z PROC		; std::char_traits<char>::assign, COMDAT
; __First$ = ecx
; __Count$dead$ = edx

; 559  : 		{	// assign _Count * _Ch to [_First, ...)

	push	ebp
	mov	ebp, esp

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	movsx	edx, BYTE PTR __Ch$[ebp]
	movzx	eax, dl
	shl	dx, 8
	or	dx, ax
	mov	eax, ecx
	mov	BYTE PTR [ecx], dl

; 561  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAPADPADID@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 565  : 		_Left = _Right;

	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 566  : 		}

	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT
?to_char_type@?$char_traits@D@std@@SADABH@Z PROC	; std::char_traits<char>::to_char_type, COMDAT
; __Meta$ = ecx

; 583  : 		return ((_Elem)_Meta);

	mov	al, BYTE PTR [ecx]

; 584  : 		}

	ret	0
?to_char_type@?$char_traits@D@std@@SADABH@Z ENDP	; std::char_traits<char>::to_char_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT
?to_int_type@?$char_traits@D@std@@SAHABD@Z PROC		; std::char_traits<char>::to_int_type, COMDAT
; __Ch$ = ecx

; 589  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [ecx]

; 590  : 		}

	ret	0
?to_int_type@?$char_traits@D@std@@SAHABD@Z ENDP		; std::char_traits<char>::to_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 594  : 		{	// test for metacharacter equality

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	sete	al

; 595  : 		return (_Left == _Right);
; 596  : 		}

	ret	0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 606  : 		return (EOF);

	or	eax, -1

; 607  : 		}

	ret	0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Try_aligned_allocation$dead$ = 8			; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT
; __Count$ = ecx
; __Sz$dead$ = edx

; 49   : 	void *_Ptr = 0;
; 50   : 
; 51   : 	if (_Count == 0)

	test	ecx, ecx
	jne	SHORT $LN2@Allocate

; 52   : 		return (_Ptr);

	xor	eax, eax

; 87   : 	}

	ret	0
$LN2@Allocate:

; 53   : 
; 54   : 	// check overflow of multiply
; 55   : 	if ((size_t)(-1) / _Sz < _Count)
; 56   : 		_Xbad_alloc();	// report no memory
; 57   : 	const size_t _User_size = _Count * _Sz;
; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN4@Allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	eax, DWORD PTR [ecx+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	eax, ecx
	ja	SHORT $LN6@Allocate

; 67   : 			_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN6@Allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);
; 85   : 		}
; 86   : 	return (_Ptr);

	mov	eax, ecx

; 87   : 	}

	ret	0
$LN4@Allocate:

; 74   : 
; 75   :  #ifdef _DEBUG
; 76   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 77   :  #endif /* _DEBUG */
; 78   : 		}
; 79   : 	else
; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   : 
; 82   : 		{	// allocate normal block
; 83   : 		_Ptr = ::operator new(_User_size);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	ecx, eax

; 87   : 	}

	ret	0
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Sz$dead$ = 8						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT
; __Ptr$ = ecx
; __Count$ = edx

; 93   :  #if defined(_M_IX86) || defined(_M_X64)
; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);
; 95   : 	const size_t _User_size = _Count * _Sz;
; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN3@Deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	je	SHORT $LN4@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4@Deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jb	SHORT $LN5@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN5@Deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jae	SHORT $LN6@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN6@Deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	jbe	SHORT $LN7@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN7@Deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN3@Deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 133  : 	}

	ret	0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\matt\documents\visual studio 2015\projects\counter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\matt\documents\visual studio 2015\projects\counter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\users\matt\documents\visual studio 2015\projects\counter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\users\matt\documents\visual studio 2015\projects\counter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\matt\documents\visual studio 2015\projects\counter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\matt\documents\visual studio 2015\projects\counter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\matt\documents\visual studio 2015\projects\counter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\matt\documents\visual studio 2015\projects\counter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\matt\documents\visual studio 2015\projects\counter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\matt\documents\visual studio 2015\projects\counter\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\matt\documents\visual studio 2015\projects\counter\main.cpp
;	COMDAT _main
_TEXT	SEGMENT
_other$1$ = -44						; size = 4
_words$ = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_main	PROC						; COMDAT

; 7    : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$_main
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 8    : 	cout << "Write something: " << endl;

	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	mov	edx, OFFSET ??_C@_0BC@KPFACFOE@Write?5something?3?5?$AA@
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR _words$[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR _words$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR _words$[ebp], 0
; File c:\users\matt\documents\visual studio 2015\projects\counter\main.cpp

; 9    : 	string words;

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 10   : 	
; 11   : 	getline(cin, words); //getline

	mov	esi, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 161  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

	push	10					; 0000000aH
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
	call	DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	movzx	eax, al
	lea	edx, DWORD PTR _words$[ebp]
	push	eax
	mov	ecx, esi
	call	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
; File c:\users\matt\documents\visual studio 2015\projects\counter\main.cpp

; 17   : 	for (int i = 0; i < words.length(); i++)

	mov	edi, DWORD PTR _words$[ebp+20]
	xor	eax, eax
	mov	esi, DWORD PTR _words$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 161  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

	add	esp, 4
; File c:\users\matt\documents\visual studio 2015\projects\counter\main.cpp

; 12   : 	int alpha = 0; //alpha

	xor	edx, edx

; 13   : 	int numbers = 0; //numbers

	xor	ebx, ebx

; 14   : 	int other = 0; //other
; 15   : 	int g = 0; //g

	xor	ecx, ecx

; 17   : 	for (int i = 0; i < words.length(); i++)

	cmp	DWORD PTR _words$[ebp+16], eax
	jbe	SHORT $LN3@main

; 8    : 	cout << "Write something: " << endl;

	mov	ecx, DWORD PTR _words$[ebp+16]
	mov	DWORD PTR _other$1$[ebp], ecx
$LL4@main:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	edi, 16					; 00000010H
	lea	ecx, DWORD PTR _words$[ebp]
	cmovae	ecx, esi
; File c:\users\matt\documents\visual studio 2015\projects\counter\main.cpp

; 19   : 		if ((97 <= words[i]) && (words[i] <= 122)|| ((65 <= words[i]) && (words[i] <= 90)))

	cmp	BYTE PTR [ecx+eax], 97			; 00000061H
	jl	SHORT $LN7@main
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	edi, 16					; 00000010H
	lea	ecx, DWORD PTR _words$[ebp]
	cmovae	ecx, esi
; File c:\users\matt\documents\visual studio 2015\projects\counter\main.cpp

; 19   : 		if ((97 <= words[i]) && (words[i] <= 122)|| ((65 <= words[i]) && (words[i] <= 90)))

	cmp	BYTE PTR [ecx+eax], 122			; 0000007aH
	jle	SHORT $LN6@main
$LN7@main:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	edi, 16					; 00000010H
	lea	ecx, DWORD PTR _words$[ebp]
	cmovae	ecx, esi
; File c:\users\matt\documents\visual studio 2015\projects\counter\main.cpp

; 19   : 		if ((97 <= words[i]) && (words[i] <= 122)|| ((65 <= words[i]) && (words[i] <= 90)))

	cmp	BYTE PTR [ecx+eax], 65			; 00000041H
	jl	SHORT $LN5@main
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	edi, 16					; 00000010H
	lea	ecx, DWORD PTR _words$[ebp]
	cmovae	ecx, esi
; File c:\users\matt\documents\visual studio 2015\projects\counter\main.cpp

; 19   : 		if ((97 <= words[i]) && (words[i] <= 122)|| ((65 <= words[i]) && (words[i] <= 90)))

	cmp	BYTE PTR [ecx+eax], 90			; 0000005aH
	jg	SHORT $LN5@main
$LN6@main:

; 20   : 			alpha++;

	inc	edx
$LN5@main:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	edi, 16					; 00000010H
	lea	ecx, DWORD PTR _words$[ebp]
	cmovae	ecx, esi
; File c:\users\matt\documents\visual studio 2015\projects\counter\main.cpp

; 22   : 		if ((48 <= words[i]) && (words[i] <= 57))

	cmp	BYTE PTR [ecx+eax], 48			; 00000030H
	jl	SHORT $LN8@main
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	edi, 16					; 00000010H
	lea	ecx, DWORD PTR _words$[ebp]
	cmovae	ecx, esi
; File c:\users\matt\documents\visual studio 2015\projects\counter\main.cpp

; 22   : 		if ((48 <= words[i]) && (words[i] <= 57))

	cmp	BYTE PTR [ecx+eax], 57			; 00000039H
	jg	SHORT $LN8@main

; 23   : 			numbers++;

	inc	ebx
$LN8@main:

; 17   : 	for (int i = 0; i < words.length(); i++)

	inc	eax
	cmp	eax, DWORD PTR _words$[ebp+16]
	jb	SHORT $LL4@main
	mov	ecx, DWORD PTR _other$1$[ebp]
$LN3@main:

; 24   : 		g++;
; 25   : 	}
; 26   : 
; 27   : 	if (g >= (numbers + alpha))

	lea	eax, DWORD PTR [ebx+edx]
	cmp	ecx, eax
	jl	SHORT $LN9@main

; 28   : 		other =g - (numbers + alpha);

	sub	ecx, ebx
	sub	ecx, edx
	mov	DWORD PTR _other$1$[ebp], ecx

; 29   : 	else

	jmp	SHORT $LN10@main
$LN9@main:

; 30   : 		other =(numbers + alpha) - g;

	mov	eax, ebx
	sub	eax, ecx
	add	eax, edx
	mov	DWORD PTR _other$1$[ebp], eax
$LN10@main:

; 31   : 
; 32   : 	cout << "number of letters: " << alpha << endl;

	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	edx
	mov	edx, OFFSET ??_C@_0BE@IIDGBEEB@number?5of?5letters?3?5?$AA@
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 33   : 	cout << "number of numbers: " << numbers << endl;

	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	mov	edx, OFFSET ??_C@_0BE@EHPJAFPJ@number?5of?5numbers?3?5?$AA@
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	ebx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 34   : 	cout << "number of other: " << other;

	mov	ecx, DWORD PTR _other$1$[ebp]
	mov	edx, OFFSET ??_C@_0BC@KCLPILPH@number?5of?5other?3?5?$AA@
	push	ecx
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	edi, 16					; 00000010H
	jb	SHORT $LN336@main

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	lea	eax, DWORD PTR [edi+1]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN331@main

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	BYTE PTR _words$[ebp], 31		; 0000001fH
	je	SHORT $LN332@main
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN373@main:
$LN332@main:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [esi-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, esi
	jb	SHORT $LN333@main
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN374@main:
$LN333@main:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	esi, eax
	cmp	esi, 4
	jae	SHORT $LN334@main
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN375@main:
$LN334@main:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	esi, 35					; 00000023H
	jbe	SHORT $LN335@main
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN376@main:
$LN335@main:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	esi, eax
$LN331@main:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN336@main:
; File c:\users\matt\documents\visual studio 2015\projects\counter\main.cpp

; 35   : 	return 0;

	xor	eax, eax

; 36   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN372@main:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_main$0:
	lea	ecx, DWORD PTR _words$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$_main:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$_main
	jmp	___CxxFrameHandler3
text$x	ENDS
_main	ENDP
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT
; _this$ = ecx

; 1760 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx+16]

; 1761 : 		}

	ret	0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 1679 : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1688 : 		return (this->_Myptr()[_Off]);

	mov	eax, DWORD PTR __Off$[ebp]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN13@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN13@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1688 : 		return (this->_Myptr()[_Off]);

	add	eax, ecx

; 1689 : 		}

	pop	ebp
	ret	4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1016 : 		{	// destroy the string

	push	esi
	mov	esi, ecx

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN86@basic_stri
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN81@basic_stri

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	je	SHORT $LN82@basic_stri
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN119@basic_stri:
$LN82@basic_stri:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jb	SHORT $LN83@basic_stri
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN120@basic_stri:
$LN83@basic_stri:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jae	SHORT $LN84@basic_stri
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN121@basic_stri:
$LN84@basic_stri:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	jbe	SHORT $LN85@basic_stri
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN122@basic_stri:
$LN85@basic_stri:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN81@basic_stri:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN86@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN109@basic_stri
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN109@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1018 : 		}

	ret	0
$LN118@basic_stri:
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 796  : 		}

	mov	eax, ecx

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 796  : 		}

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$dead$ = ecx
	ret	0
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$dead$ = ecx
	ret	0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$dead$ = ecx
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 142  : 			return (_Ok);

	mov	al, BYTE PTR [ecx+4]

; 143  : 			}

	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 130  : 			{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	test	al, al
	jne	SHORT $LN2@sentry

; 133  : 				this->_Myostr._Osfx();

	mov	ecx, DWORD PTR [esi]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN2@sentry:

; 106  : 			{	// destroy after unlocking

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 107  : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN5@sentry

; 108  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN5@sentry:

; 134  : 
; 135  :  #else /* _HAS_EXCEPTIONS */
; 136  : 			this->_Myostr._Osfx();
; 137  :  #endif /* _HAS_EXCEPTIONS */
; 138  : 			}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 123  : 			{	// construct locking and testing stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi

; 99   : 			: _Myostr(_Ostr)

	mov	esi, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR [edi], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 101  : 			if (_Myostr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN6@sentry

; 102  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN6@sentry:

; 103  : 			}
; 104  : 
; 105  : 		__CLR_OR_THIS_CALL ~_Sentry_base() _NOEXCEPT
; 106  : 			{	// destroy after unlocking
; 107  : 			if (_Myostr.rdbuf() != 0)
; 108  : 				_Myostr.rdbuf()->_Unlock();
; 109  : 			}
; 110  : 
; 111  : 		_Myt& _Myostr;	// the output stream, for _Unlock call at destruction
; 112  : 
; 113  : 	private:
; 114  : 		_Sentry_base& operator=(const _Sentry_base&);
; 115  : 		};
; 116  : 
; 117  : 	class sentry
; 118  : 		: public _Sentry_base
; 119  : 		{	// stores thread lock and state of stream
; 120  : 	public:
; 121  : 		explicit __CLR_OR_THIS_CALL sentry(_Myt& _Ostr)
; 122  : 			: _Sentry_base(_Ostr)

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [eax+esi+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN2@sentry
	mov	ecx, DWORD PTR [eax+esi+60]
	test	ecx, ecx
	je	SHORT $LN2@sentry
	cmp	ecx, esi
	je	SHORT $LN2@sentry

; 125  : 				_Ostr.tie()->flush();

	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$LN2@sentry:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 339  : 		return (rdstate() == goodbit);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+esi+12], 0
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	BYTE PTR [edi+4], al

; 127  : 			}

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$dead$ = ecx

; 534  : 			}

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 729  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 730  : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 697  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 698  : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 692  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 693  : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 590  : 		}

	mov	eax, ecx

; 497  : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 590  : 		}

	ret	0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN11@Myptr

; 578  : 		return (_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 579  : 		}

	ret	0
$LN11@Myptr:

; 578  : 		return (_Get_data()._Myptr());

	mov	eax, ecx

; 579  : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2248 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp

; 2249 : 		if (!_Built)

	cmp	BYTE PTR __Built$[ebp], 0
	push	esi
	push	edi
	mov	edi, DWORD PTR __Newsize$[ebp]
	mov	esi, ecx
	je	SHORT $LN84@Tidy

; 2250 : 			;
; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN84@Tidy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;

	push	ebx
	mov	ebx, DWORD PTR [esi]

; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)

	test	edi, edi
	je	SHORT $LN57@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	edi
	push	ebx
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN57@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	mov	eax, DWORD PTR [esi+20]
	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN79@Tidy

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	bl, 31					; 0000001fH
	je	SHORT $LN80@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN116@Tidy:
$LN80@Tidy:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ebx-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ebx
	jb	SHORT $LN81@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN117@Tidy:
$LN81@Tidy:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ebx, eax
	cmp	ebx, 4
	jae	SHORT $LN82@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN118@Tidy:
$LN82@Tidy:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ebx, 35					; 00000023H
	jbe	SHORT $LN83@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN119@Tidy:
$LN83@Tidy:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ebx, eax
$LN79@Tidy:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	ebx
$LN84@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN107@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN107@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+edi], 0
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2262 : 		}

	pop	ebp
	ret	8
$LN115@Tidy:
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1765 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx+16]

; 1766 : 		}

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 1059 : 		{	// append 1 * _Ch

	push	ebp
	mov	ebp, esp

; 1060 : 		return (append((size_type)1, _Ch));

	push	DWORD PTR __Ch$[ebp]
	push	ecx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1061 : 		}

	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 106  : 			{	// destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 107  : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN2@Sentry_bas

; 108  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 109  : 			}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 100  : 			{	// lock the stream buffer, if there

	push	ebp
	mov	ebp, esp

; 99   : 			: _Myostr(_Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]
	push	esi

; 100  : 			{	// lock the stream buffer, if there

	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 101  : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
	test	ecx, ecx
	je	SHORT $LN8@Sentry_bas

; 102  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 103  : 			}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

	ret	0
$LN3@Myptr:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, ecx

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$dead$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	DWORD PTR __Count$[ebp], 4096		; 00001000H

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	eax, DWORD PTR __Ptr$[ebp]

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	jb	SHORT $LN7@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	al, 31					; 0000001fH
	je	SHORT $LN8@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@deallocate:
$LN8@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jb	SHORT $LN9@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@deallocate:
$LN9@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jae	SHORT $LN10@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN10@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	jbe	SHORT $LN11@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN11@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, ecx
$LN7@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	pop	ebp
	ret	8
$LN16@deallocate:
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres, COMDAT
; _this$ = ecx

; 734  : 		return (_Get_data()._Myres);

	lea	eax, DWORD PTR [ecx+20]

; 735  : 		}

	ret	0
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 724  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 725  : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx, COMDAT
; _this$ = ecx

; 714  : 		return (_Get_data()._Bx);

	mov	eax, ecx

; 715  : 		}

	ret	0
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 707  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 708  : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 702  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 703  : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset, COMDAT
; _this$dead$ = ecx

; 2271 : 		if (this->_Mysize() < _Off)
; 2272 : 			_Xran();
; 2273 : 		}

	ret	4
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$dead$ = ecx

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$dead$ = 12					; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2224 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	push	esi

; 2225 : 		if (max_size() < _Newsize)

	mov	esi, DWORD PTR __Newsize$[ebp]
	cmp	esi, -2					; fffffffeH
	jbe	SHORT $LN2@Grow

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN90@Grow:
$LN2@Grow:

; 2226 : 			_Xlen();	// result too long
; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [ecx+20], esi
	jae	SHORT $LN5@Grow

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	DWORD PTR [ecx+16]
	push	esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	esi, esi
	pop	esi
	setne	al

; 2235 : 		}

	pop	ebp
	ret	8
$LN5@Grow:

; 2229 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2230 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2231 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2232 : 		else if (_Newsize == 0)

	test	esi, esi
	jne	SHORT $LN88@Grow

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], esi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN80@Grow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN80@Grow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
	test	esi, esi
$LN88@Grow:
	setne	al
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2235 : 		}

	pop	ebp
	ret	8
$LN89@Grow:
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN11@Eos
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2220 : 		}

	pop	ebp
	ret	4
$LN11@Eos:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+edx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2220 : 		}

	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
__Ch$ = 16						; size = 1
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign, COMDAT
; _this$ = ecx

; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off

	push	ebp
	mov	ebp, esp

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	mov	edx, DWORD PTR __Off$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	al, BYTE PTR __Ch$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN15@Chassign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN15@Chassign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+edx], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2179 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN29@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1343 : 		return (*this);

	mov	eax, ecx

; 1344 : 		}

	ret	4
$LN29@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1343 : 		return (*this);

	mov	eax, ecx

; 1344 : 		}

	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1111 : 		{	// append _Count * _Ch

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 1112 : 		if (npos - this->_Mysize() <= _Count)

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, ecx
	not	eax
	cmp	eax, 1
	ja	SHORT $LN2@append

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN179@append:
$LN2@append:

; 1113 : 			_Xlen();	// result too long
; 1114 : 
; 1115 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	edi, DWORD PTR [ecx+1]

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN27@append

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN180@append:
$LN27@append:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN28@append

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	ecx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1116 : 		if (0 < _Count && _Grow(_Num))

	je	SHORT $LN173@append
$LN177@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1117 : 			{	// make room and append new stuff using assign
; 1118 : 			_Chassign(this->_Mysize(), _Count, _Ch);

	mov	edx, DWORD PTR [esi+16]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN135@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN136@append
$LN28@append:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN177@append

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN105@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1121 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1122 : 		}

	pop	ebp
	ret	8
$LN105@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1122 : 		}

	pop	ebp
	ret	8
$LN135@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	ecx, esi
$LN136@append:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	al, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [ecx+edx], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN168@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1121 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi

; 1122 : 		}

	pop	ebp
	ret	8
$LN168@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN173@append:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1121 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1122 : 		}

	pop	ebp
	ret	8
$LN178@append:
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$dead$ = ecx

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN4@Xran:
$LN3@Xran:
	int	3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	edi, eax
	or	edi, 15					; 0000000fH

; 2184 : 		if (max_size() < _Newres)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN2@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	edi, eax

; 2186 : 		else if (this->_Myres() / 2 <= _Newres / 3)

	jmp	SHORT $LN108@Copy
$LN2@Copy:
	mov	ebx, DWORD PTR [esi+20]
	mov	eax, -1431655765			; aaaaaaabH
	mul	edi
	mov	ecx, ebx
	shr	ecx, 1
	shr	edx, 1
	cmp	ecx, edx
	jbe	SHORT $LN108@Copy

; 2187 : 			;
; 2188 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)

	mov	eax, -2					; fffffffeH

; 2189 : 			_Newres = this->_Myres()

	lea	edi, DWORD PTR [ecx+ebx]
	sub	eax, ecx
	cmp	ebx, eax
	jbe	SHORT $LN108@Copy

; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	edi, -2					; fffffffeH
$LN108@Copy:

; 2190 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		pointer _Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 51   : 	if (_Count == 0)

	test	eax, eax
	jne	SHORT $LN136@Copy

; 52   : 		return (_Ptr);

	xor	ebx, ebx
	jmp	$LN19@Copy
$LN136@Copy:

; 53   : 
; 54   : 	// check overflow of multiply
; 55   : 	if ((size_t)(-1) / _Sz < _Count)
; 56   : 		_Xbad_alloc();	// report no memory
; 57   : 	const size_t _User_size = _Count * _Sz;
; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN138@Copy

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN140@Copy

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN367@Copy:
$LN140@Copy:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ebx, DWORD PTR [eax+35]
	and	ebx, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ebx-4], eax

; 74   : 
; 75   :  #ifdef _DEBUG
; 76   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 77   :  #endif /* _DEBUG */
; 78   : 		}
; 79   : 	else

	jmp	SHORT $LN19@Copy
$LN138@Copy:

; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   : 
; 82   : 		{	// allocate normal block
; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	ebx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
	jmp	SHORT $LN19@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	add	eax, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 51   : 	if (_Count == 0)

	je	SHORT $LN157@Copy
$LN158@Copy:

; 53   : 
; 54   : 	// check overflow of multiply
; 55   : 	if ((size_t)(-1) / _Sz < _Count)
; 56   : 		_Xbad_alloc();	// report no memory
; 57   : 	const size_t _User_size = _Count * _Sz;
; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN160@Copy

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN162@Copy

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN368@Copy:
$LN162@Copy:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 74   : 
; 75   :  #ifdef _DEBUG
; 76   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 77   :  #endif /* _DEBUG */
; 78   : 		}
; 79   : 	else

	jmp	SHORT $LN157@Copy
$LN160@Copy:

; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   : 
; 82   : 		{	// allocate normal block
; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN157@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	mov	DWORD PTR __Ptr$[ebp], eax

; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END

	mov	eax, $LN364@Copy
	ret	0
$LN364@Copy:
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR __Newres$[ebp]
	mov	ebx, DWORD PTR __Ptr$[ebp]
$LN19@Copy:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	mov	eax, DWORD PTR __Oldlen$[ebp]
	test	eax, eax
	je	SHORT $LN187@Copy

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN178@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN179@Copy
$LN178@Copy:
	mov	ecx, esi
$LN179@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	eax, eax
	je	SHORT $LN187@Copy
	push	eax
	push	ecx
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN187@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN271@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN266@Copy

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	je	SHORT $LN267@Copy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN369@Copy:
$LN267@Copy:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jb	SHORT $LN268@Copy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN370@Copy:
$LN268@Copy:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jae	SHORT $LN269@Copy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN371@Copy:
$LN269@Copy:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	jbe	SHORT $LN270@Copy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN372@Copy:
$LN270@Copy:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN266@Copy:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN271@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN294@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN295@Copy
$LN294@Copy:
	mov	eax, esi
$LN295@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	eax, DWORD PTR __Oldlen$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [esi], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2212 : 		this->_Myres() = _Newres;

	mov	DWORD PTR [esi+20], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN358@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, ebx
$LN358@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	mov	ecx, DWORD PTR _this$[ebp]
	push	0
	push	1
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN373@Copy:
$LN366@Copy:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$dead$ = ecx

; 1770 : 		const size_type _Num = this->_Getal().max_size();
; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	eax, -2					; fffffffeH

; 1772 : 		}

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$dead$ = ecx

; 719  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	DWORD PTR __Count$[ebp], 4096		; 00001000H

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	eax, DWORD PTR __Ptr$[ebp]

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	jb	SHORT $LN5@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	al, 31					; 0000001fH
	je	SHORT $LN6@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN14@deallocate:
$LN6@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jb	SHORT $LN7@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN15@deallocate:
$LN7@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jae	SHORT $LN8@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN16@deallocate:
$LN8@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	jbe	SHORT $LN9@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@deallocate:
$LN9@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, ecx
$LN5@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 721  : 		}

	pop	ebp
	ret	8
$LN13@deallocate:
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$dead$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	or	eax, -1

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$dead$ = ecx

; 975  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN6@allocate

; 52   : 		return (_Ptr);

	xor	ecx, ecx

; 976  : 		return (_Mybase::allocate(_Count));

	mov	eax, ecx

; 977  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN10@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN18@allocate:
$LN10@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 976  : 		return (_Mybase::allocate(_Count));

	mov	eax, ecx

; 977  : 		}

	pop	ebp
	ret	4
$LN8@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	ecx, eax

; 977  : 		}

	pop	ebp
	ret	4
$LN17@allocate:
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT
; __Al$dead$ = ecx

; 869  : 		return (_Al.max_size());

	or	eax, -1

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$dead$ = ecx

; 724  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate

; 52   : 		return (_Ptr);

	xor	ecx, ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	ecx, eax

; 726  : 		}

	pop	ebp
	ret	4
$LN14@allocate:
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$dead$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 750  : 		}

	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
__Ok$ = -44						; size = 8
__Pad$ = -44						; size = 8
__State$ = -36						; size = 4
__Val$1$ = -32						; size = 4
$T19 = -32						; size = 1
$T13 = -28						; size = 1
__Ostr$ = -24						; size = 4
__Count$2$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT
; __Ostr$ = ecx
; __Val$ = edx

; 780  : 	{	// insert NTBS into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	eax, edx
	mov	DWORD PTR __Val$1$[ebp], eax
	mov	ebx, ecx
	mov	DWORD PTR __Ostr$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 783  : 	ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	jne	SHORT $LN26@operator
	xor	ecx, ecx
	jmp	SHORT $LN121@operator
$LN26@operator:
	mov	ecx, eax
	lea	edx, DWORD PTR [ecx+1]
	npad	6
$LL108@operator:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL108@operator
	sub	ecx, edx
$LN121@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 423  : 		return (_Wide);

	mov	eax, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	DWORD PTR __Count$2$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 423  : 		return (_Wide);

	mov	eax, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax+ebx+36]
	mov	esi, DWORD PTR [eax+ebx+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 785  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

	test	edi, edi
	jl	SHORT $LN17@operator
	jg	SHORT $LN110@operator
	test	esi, esi
	je	SHORT $LN17@operator
	test	edi, edi
	jl	SHORT $LN17@operator
	jg	SHORT $LN110@operator
	cmp	esi, ecx
	jbe	SHORT $LN17@operator
$LN110@operator:
	sub	esi, ecx
	sbb	edi, 0
	jmp	SHORT $LN18@operator
$LN17@operator:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR __Pad$[ebp], xmm0
	mov	edi, DWORD PTR __Pad$[ebp+4]
	mov	esi, DWORD PTR __Pad$[ebp]
$LN18@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	ecx, DWORD PTR [eax+ebx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 99   : 			: _Myostr(_Ostr)

	mov	DWORD PTR __Ok$[ebp], ebx

; 100  : 			{	// lock the stream buffer, if there
; 101  : 			if (_Myostr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN39@operator

; 102  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN39@operator:

; 122  : 			: _Sentry_base(_Ostr)

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [eax+ebx+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN35@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 80   : 		return (_Tiestr);

	mov	ecx, DWORD PTR [eax+ebx+60]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	test	ecx, ecx
	je	SHORT $LN35@operator
	cmp	ecx, ebx
	je	SHORT $LN35@operator

; 125  : 				_Ostr.tie()->flush();

	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$LN35@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [ecx+ebx+12], 0
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	BYTE PTR __Ok$[ebp+4], al

; 786  : 		? 0 : _Ostr.width() - _Count;
; 787  : 	const typename _Myos::sentry _Ok(_Ostr);

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 788  : 
; 789  : 	if (!_Ok)

	test	al, al
	jne	SHORT $LN8@operator

; 790  : 		_State |= ios_base::badbit;

	mov	ecx, 4

; 791  : 	else

	jmp	$LN22@operator
$LN8@operator:

; 792  : 		{	// state okay, insert
; 793  : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 378  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [ecx+ebx+20]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 794  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN105@operator
	npad	2
$LL4@operator:

; 795  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	test	edi, edi
	jl	SHORT $LN3@operator
	jg	SHORT $LN111@operator
	test	esi, esi
	je	SHORT $LN3@operator
$LN111@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	mov	al, BYTE PTR [ecx+ebx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 796  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	ecx, DWORD PTR [ecx+ebx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	BYTE PTR $T13[ebp], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 796  : 				if (_Traits::eq_int_type(_Traits::eof(),

	push	DWORD PTR $T13[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	eax, -1
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 796  : 				if (_Traits::eq_int_type(_Traits::eof(),

	test	al, al
	je	SHORT $LN2@operator
$LN112@operator:

; 797  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 798  : 					{	// insertion failed, quit
; 799  : 					_State |= ios_base::badbit;

	mov	ecx, 4

; 800  : 					break;

	jmp	SHORT $LN6@operator
$LN2@operator:

; 795  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	add	esi, -1
	adc	edi, -1
	jmp	SHORT $LL4@operator
$LN3@operator:
	xor	ecx, ecx

; 804  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	jne	SHORT $LN6@operator
$LN105@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 804  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	push	0
	push	DWORD PTR __Count$2$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 804  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	push	DWORD PTR __Val$1$[ebp]
	mov	ecx, DWORD PTR [eax+ebx+56]
	call	DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
	cmp	eax, DWORD PTR __Count$2$[ebp]
	jne	SHORT $LN112@operator
	test	edx, edx
	jne	SHORT $LN112@operator
$LL114@operator:

; 805  : 			_State |= ios_base::badbit;
; 806  : 
; 807  : 		if (_State == ios_base::goodbit)
; 808  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	test	edi, edi
	jl	SHORT $LN118@operator
	jg	SHORT $LN113@operator
	test	esi, esi
	je	SHORT $LN118@operator
$LN113@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	mov	al, BYTE PTR [ecx+ebx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 809  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	ecx, DWORD PTR [ecx+ebx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	BYTE PTR $T19[ebp], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 809  : 				if (_Traits::eq_int_type(_Traits::eof(),

	push	DWORD PTR $T19[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	eax, -1
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 809  : 				if (_Traits::eq_int_type(_Traits::eof(),

	test	al, al
	je	SHORT $LN5@operator

; 810  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 811  : 					{	// insertion failed, quit
; 812  : 					_State |= ios_base::badbit;

	xor	ecx, ecx
	or	ecx, 4

; 813  : 					break;

	jmp	SHORT $LN6@operator
$LN5@operator:

; 805  : 			_State |= ios_base::badbit;
; 806  : 
; 807  : 		if (_State == ios_base::goodbit)
; 808  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	add	esi, -1
	adc	edi, -1
	jmp	SHORT $LL114@operator
$LN118@operator:
	xor	ecx, ecx
$LN6@operator:

; 814  : 					}
; 815  : 		_Ostr.width(0);

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 429  : 		_Wide = _Newwidth;

	mov	DWORD PTR [eax+ebx+32], 0
	mov	DWORD PTR [eax+ebx+36], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
	jmp	SHORT $LN124@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 816  : 		_CATCH_IO_(_Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]
	push	1
	push	4
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	mov	eax, $LN23@operator
	ret	0
$LN23@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
	mov	ebx, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR __State$[ebp]
$LN124@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
$LN22@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 817  : 		}
; 818  : 
; 819  : 	_Ostr.setstate(_State);

	mov	eax, DWORD PTR [ebx]
	push	0
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, ebx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 130  : 			{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+12], 4

; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ

; 133  : 				this->_Myostr._Osfx();

	mov	esi, DWORD PTR __Ok$[ebp]
	test	al, al
	jne	SHORT $LN88@operator
	mov	ecx, esi
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN88@operator:

; 106  : 			{	// destroy after unlocking

	mov	BYTE PTR __$EHRec$[ebp+12], 5

; 107  : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
	test	ecx, ecx
	je	SHORT $LN115@operator

; 108  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN115@operator:

; 820  : 	return (_Ostr);

	mov	eax, ebx

; 821  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$8:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$9:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 991  : 	{	// insert newline and flush stream

	push	ebp
	mov	ebp, esp
	push	esi

; 992  : 	_Ostr.put(_Ostr.widen('\n'));

	mov	esi, DWORD PTR __Ostr$[ebp]
	push	10					; 0000000aH
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
	call	DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	movzx	ecx, al
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z

; 993  : 	_Ostr.flush();

	mov	ecx, esi
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 994  : 	return (_Ostr);

	mov	eax, esi
	pop	esi

; 995  : 	}

	pop	ebp
	ret	0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; __Istr$ = ecx
; __Str$ = edx

; 160  : 	{	// get characters into string, discard newline

	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, edx

; 161  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

	push	10					; 0000000aH
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edi
	call	DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	movzx	eax, al
	mov	edx, esi
	push	eax
	mov	ecx, edi
	call	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 4
	pop	edi
	pop	esi

; 162  : 	}

	ret	0
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 497  : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT
; __Val$ = ecx

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, ecx

; 726  : 	}

	ret	0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$dead$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT
; __Ptr$ = ecx

; 740  : 	return (_Ptr);

	mov	eax, ecx

; 741  : 	}

	ret	0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$dead$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 499  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+20], 0
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 529  : 			{	// user-provided, for fancy pointers
; 530  : 			}

	mov	eax, ecx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::move<std::basic_istream<char,std::char_traits<char> > &>, COMDAT
; __Arg$ = ecx

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, ecx

; 1293 : 	}

	ret	0
??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::move<std::basic_istream<char,std::char_traits<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT
__Ok$ = -44						; size = 8
__State$ = -36						; size = 4
__Metadelim$1$ = -32					; size = 4
__Istr$GSCopy$ = -28					; size = 4
__Str$GSCopy$1$ = -24					; size = 4
__Changed$ = -17					; size = 1
__$EHRec$ = -16						; size = 16
__Delim$ = 8						; size = 1
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; __Istr$ = ecx
; __Str$ = edx

; 77   : 	{	// get characters into string, discard delimiter

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Str$GSCopy$1$[ebp], edx
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 80   : 	ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi

; 81   : 	bool _Changed = false;

	xor	bl, bl
	mov	DWORD PTR __Istr$GSCopy$[ebp], esi
	mov	DWORD PTR __State$[ebp], edi
	mov	BYTE PTR __Changed$[ebp], bl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream

; 93   : 			: _Myistr(_Istr)

	mov	DWORD PTR __Ok$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	ecx, DWORD PTR [eax+esi+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream

; 95   : 			if (_Myistr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN24@getline

; 96   : 				_Myistr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN24@getline:

; 118  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

	push	1
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	DWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	mov	BYTE PTR __Ok$[ebp+4], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 82   : 	const typename _Myis::sentry _Ok(_Istr, true);

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 83   : 
; 84   : 	if (_Ok)

	test	al, al
	je	$LN137@getline
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	eax, DWORD PTR __Str$GSCopy$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 86   : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [eax+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [eax+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN60@getline
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN60@getline:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0

; 589  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR __Delim$[ebp]
	mov	DWORD PTR __Metadelim$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 90   : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

	mov	ecx, DWORD PTR [eax+esi+56]
	call	DWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
$LN140@getline:
	mov	ecx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	ecx, -1
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 93   : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

	test	al, al
	je	SHORT $LN7@getline

; 94   : 				{	// end of file, quit
; 95   : 				_State |= ios_base::eofbit;

	mov	edi, 1

; 96   : 				break;

	jmp	SHORT $LN3@getline
$LN7@getline:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	ecx, DWORD PTR __Metadelim$1$[ebp]
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 98   : 			else if (_Traits::eq_int_type(_Meta, _Metadelim))

	test	al, al
	je	SHORT $LN9@getline
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 100  : 				_Changed = true;

	mov	bl, 1
	mov	BYTE PTR __Changed$[ebp], bl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 101  : 				_Istr.rdbuf()->sbumpc();

	mov	ecx, DWORD PTR [eax+esi+56]
	call	DWORD PTR __imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ

; 102  : 				break;

	jmp	SHORT $LN3@getline
$LN9@getline:

; 103  : 				}
; 104  : 			else if (_Str.max_size() <= _Str.size())

	mov	eax, DWORD PTR __Str$GSCopy$1$[ebp]
	cmp	DWORD PTR [eax+16], -2			; fffffffeH
	jb	SHORT $LN11@getline

; 105  : 				{	// string too large, quit
; 106  : 				_State |= ios_base::failbit;

	mov	edi, 2
	jmp	SHORT $LN3@getline
$LN11@getline:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1060 : 		return (append((size_type)1, _Ch));

	push	ecx
	push	ecx
	mov	ecx, eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 112  : 				_Changed = true;

	mov	bl, 1
	mov	BYTE PTR __Changed$[ebp], bl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 92   : 		for (; ; _Meta = _Istr.rdbuf()->snextc())

	mov	ecx, DWORD PTR [eax+esi+56]
	call	DWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
	jmp	SHORT $LN140@getline
__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0:

; 113  : 				}
; 114  : 		_CATCH_IO_(_Istr)

	mov	edx, DWORD PTR __Istr$GSCopy$[ebp]
	push	1
	push	4
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	mov	eax, $LN19@getline
	ret	0
$LN19@getline:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
	mov	edi, DWORD PTR __State$[ebp]
	mov	bl, BYTE PTR __Changed$[ebp]
	mov	esi, DWORD PTR __Istr$GSCopy$[ebp]
$LN3@getline:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 115  : 		}
; 116  : 
; 117  : 	if (!_Changed)

	test	bl, bl
	jne	SHORT $LN13@getline
$LN137@getline:

; 118  : 		_State |= ios_base::failbit;

	or	edi, 2
$LN13@getline:

; 119  : 	_Istr.setstate(_State);

	mov	eax, DWORD PTR [esi]
	push	0
	push	edi
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream

; 100  : 			{	// destroy after unlocking

	mov	DWORD PTR __$EHRec$[ebp+12], 4

; 101  : 			if (_Myistr.rdbuf() != 0)

	mov	eax, DWORD PTR __Ok$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+eax+56]
	test	ecx, ecx
	je	SHORT $LN138@getline

; 102  : 				_Myistr.rdbuf()->_Unlock();

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
$LN138@getline:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 120  : 	return (_Istr);

	mov	eax, esi

; 121  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$3:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$26:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
$LN8@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 100  : 			{	// destroy after unlocking

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 101  : 			if (_Myistr.rdbuf() != 0)

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN4@sentry

; 102  : 				_Myistr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN4@sentry:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ$0:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 123  : 			return (_Ok);

	mov	al, BYTE PTR [ecx+4]

; 124  : 			}

	ret	0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$dead$ = 12					; size = 1
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 117  : 			{	// construct locking and calling _Ipfx

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 93   : 			: _Myistr(_Istr)

	mov	edx, DWORD PTR __Istr$[ebp]
	mov	DWORD PTR [esi], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream

; 95   : 			if (_Myistr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN5@sentry

; 96   : 				_Myistr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN5@sentry:

; 97   : 			}
; 98   : 
; 99   : 		__CLR_OR_THIS_CALL ~_Sentry_base() _NOEXCEPT
; 100  : 			{	// destroy after unlocking
; 101  : 			if (_Myistr.rdbuf() != 0)
; 102  : 				_Myistr.rdbuf()->_Unlock();
; 103  : 			}
; 104  : 
; 105  : 		_Myt& _Myistr;	// the input stream, for _Unlock call at destruction
; 106  : 
; 107  : 	private:
; 108  : 		_Sentry_base& operator=(const _Sentry_base&);
; 109  : 		};
; 110  : 
; 111  : 	class sentry
; 112  : 		: public _Sentry_base
; 113  : 		{	// stores thread lock and result of _Ipfx call
; 114  : 	public:
; 115  : 		explicit __CLR_OR_THIS_CALL sentry(_Myt& _Istr, bool _Noskip = false)
; 116  : 			: _Sentry_base(_Istr)

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 118  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

	mov	ecx, DWORD PTR [esi]
	push	1
	call	DWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	mov	BYTE PTR [esi+4], al

; 119  : 			}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 100  : 			{	// destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 101  : 			if (_Myistr.rdbuf() != 0)

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN2@Sentry_bas

; 102  : 				_Myistr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 103  : 			}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 94   : 			{	// lock the stream buffer, if there

	push	ebp
	mov	ebp, esp

; 93   : 			: _Myistr(_Istr)

	mov	edx, DWORD PTR __Istr$[ebp]
	push	esi

; 94   : 			{	// lock the stream buffer, if there

	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 95   : 			if (_Myistr.rdbuf() != 0)

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
	test	ecx, ecx
	je	SHORT $LN8@Sentry_bas

; 96   : 				_Myistr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 97   : 			}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$dead$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$dead$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

	pop	ebp
	ret	8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
_TEXT	ENDS
END
